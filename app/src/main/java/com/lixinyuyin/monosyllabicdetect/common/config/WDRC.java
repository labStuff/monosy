package com.lixinyuyin.monosyllabicdetect.common.config;

/**
 * Created by zqj on 2016/4/12 10:19.
 */
public class WDRC {

    public static final int partNum = 8;

    static final double[][] mBaseB = new double[][]{
            new double[]{0.001871973570444, -0.007473894759812, 0.009331880917345, 0.000000000000000, -0.009331880917345, 0.007473894759812, -0.001871973570444},
            new double[]{0.004142394701180, -0.016454321051591, 0.020481716424580, -0.000000000000000, -0.020481716424580, 0.016454321051591, -0.004142394701180},
            new double[]{0.004418491995863, -0.017416260308598, 0.021579246655640, 0.000000000000000, -0.021579246655640, 0.017416260308598, -0.004418491995863},
            new double[]{0.004693747946743, -0.018277107425315, 0.022482620702753, 0.000000000000000, -0.022482620702753, 0.018277107425315, -0.004693747946743},
            new double[]{0.006706786534057, -0.025483029230527, 0.030893399519973, 0.000000000000000, -0.030893399519973, 0.025483029230527, -0.006706786534057},
            new double[]{0.006868347616622, -0.025211734750480, 0.029969373129120, 0.000000000000000, -0.029969373129120, 0.025211734750480, -0.006868347616622},
            new double[]{0.006975882221987, -0.024452472841123, 0.028348862135556, -0.000000000000000, -0.028348862135556, 0.024452472841123, -0.006975882221987},
            new double[]{0.007029662872029, -0.023229764993002, 0.026142357521178, 0.000000000000000, -0.026142357521178, 0.023229764993002, -0.007029662872029},
            new double[]{0.007029659341867, -0.021589093478366, 0.023503696639133, 0.000000000000000, -0.023503696639133, 0.021589093478366, -0.007029659341867},
            new double[]{0.007083360353713, -0.019877707644738, 0.020899449643860, 0.000000000000000, -0.020899449643860, 0.019877707644738, -0.007083360353713},
            new double[]{0.014594527150563, -0.033182226870501, 0.031907491697375, 0.000000000000000, -0.031907491697375, 0.033182226870501, -0.014594527150563},
            new double[]{0.014853921185462, -0.023123368989684, 0.021781579100407, -0.000000000000000, -0.021781579100407, 0.023123368989684, -0.014853921185462},
            new double[]{0.015113304766692, -0.011424044196553, 0.014777056610586, -0.000000000000000, -0.014777056610586, 0.011424044196553, -0.015113304766692},
            new double[]{0.015372705632048, 0.001439588294273, 0.012680152478411, -0.000000000000000, -0.012680152478411, -0.001439588294273, -0.015372705632048},
            new double[]{0.035530895557600, 0.044885772322397, 0.024621848650095, 0.000000000000000, -0.024621848650095, -0.044885772322397, -0.035530895557600},
            new double[]{0.074249602025634, 0.155873831138768, 0.088998862125885, -0.000000000000000, -0.088998862125885, -0.155873831138768, -0.074249602025634}
    };

    static final double[][] mBaseA = new double[][]{
            new double[]{1.000000000000000, -5.964439173147686, 14.830720804135797, -19.678301603992882, 14.694993278426750, -5.855768870895474, 0.972795581713064},
            new double[]{1.000000000000000, -5.912652433172715, 14.591799151172648, -19.239191353486511, 14.293525851993120, -5.673406885905156, 0.939926149050063},
            new double[]{1.000000000000000, -5.865294864971820, 14.401672227185339, -18.947588339654182, 14.087338814578027, -5.612062737324604, 0.935945713297304},
            new double[]{1.000000000000000, -5.792453637629190, 14.114382377704814, -18.513913768600936, 13.786798240134122, -5.526704807596817, 0.931982057047943},
            new double[]{1.000000000000000, -5.643520111571514, 13.515665217286589, -17.566167049980201, 13.064430267512662, -5.272997301473366, 0.903165254259823},
            new double[]{1.000000000000000, -5.451748822931998, 12.803489845977815, -16.529845782254831, 12.365535633459345, -5.085170629943578, 0.900867689109100},
            new double[]{1.000000000000000, -5.205858881876125, 11.927731564615065, -15.272328307113831, 11.513232403206771, -4.850320344091601, 0.899339854808817},
            new double[]{1.000000000000000, -4.907625064222363, 10.920844443715112, -13.845400874245900, 10.538372935656295, -4.569864677681816, 0.898576180436937},
            new double[]{1.000000000000000, -4.561011685939345, 9.826154710947762, -12.312067400291108, 9.482049290711721, -4.247106635220588, 0.898576230554988},
            new double[]{1.000000000000000, -4.167549458337756, 8.679753378831874, -10.716474516693550, 8.373457988235112, -3.878527928432087, 0.897813977834533},
            new double[]{1.000000000000000, -3.401765913164226, 6.614377141027789, -7.735877276191609, 6.128500930609816, -2.919296900781499, 0.795109766211609},
            new double[]{1.000000000000000, -2.330569048464894, 4.556535746008529, -4.758351114281022, 4.216693769526655, -1.994355657996749, 0.791736968840168},
            new double[]{1.000000000000000, -1.132362093038521, 3.164055861580008, -2.132954435539810, 2.924821973870262, -0.966256685392494, 0.788378052224300},
            new double[]{1.000000000000000, 0.140376892630250, 2.736678245492650, 0.257367195487051, 2.526653928090341, 0.119445303400681, 0.785032828064820},
            new double[]{1.000000000000000, 2.100493729112674, 3.805455958430586, 3.722778409098487, 3.177844300503578, 1.447855365601408, 0.573251517914677},
            new double[]{1.000000000000000, 4.609053029781252, 9.081822909952223, 9.953653396580165, 6.460791985187796, 2.342650185290706, 0.362741716543425}
    };

    /// <summary>
    /// 本函数主要用于得到多通道滤波器组的系数及各通道中心频率
    /// </summary>
    /// <param name="B">滤波器组系统函数的分子系数数组</param>
    /// <param name="A">滤波器组系统函数的分母系数数组</param>
    /// <param name="fc">各通道中心频率</param>
    /// <param name="num">通道数</param>
    public static void iirParams(double[][] B, double[][] A, double[] fc) {
        for (int i = 0; i < A.length; i++) {
            A[i] = mBaseA[i];
            B[i] = mBaseB[i];
        }
        //16通道的各上下限频率
        int[] fl = {100, 165, 311, 467, 633, 873, 1119, 1369, 1621, 1873, 2127, 2667, 3217, 3777, 4347, 5653};
        int[] fh = {165, 311, 467, 633, 873, 1119, 1369, 1621, 1873, 2127, 2667, 3217, 3777, 4347, 5653, 7999};

        for (int i = 0; i < fc.length; i++) {
            //获得各通道的中心频率值
            fc[i] = Math.floor((fl[i] + fh[i]) / 2.0);
            //获得各通道的滤波器系数

        }
    }

    /// <summary>
    /// 本函数主要是根据患者的听阈对其进行线性插值，得到患者在各个通道中心频率点处的听阈值(Hearing Threshold)
    /// </summary>
    /// <param name="ht">得到的各通道中心频率点处的听阈值</param>
    /// <param name="hearing">患者听阈</param>
    /// <param name="fc">各通道中心频率值</param>
    /// <param name="num">通道数</param>
    public static void linearInterp(double[] ht, double[] hearing, double[] fc) {
        double[] y = new double[8], x = {0, 125, 250, 500, 1000, 2000, 4000, 8000};

        y[0] = hearing[0];
        y[1] = hearing[0];
        for (int i = 0; i < 6; i++) {
            y[i + 2] = hearing[i];
        }

        //进行线性插值
        for (int i = 0; i < fc.length; i++) {
            for (int j = 0; j < 7; j++) {
                if (fc[i] >= x[j] && fc[i] <= x[j + 1]) {
                    ht[i] = y[j] + (y[j + 1] - y[j]) * (fc[i] - x[j]) / (x[j + 1] - x[j]);
                    break;
                }
            }
        }
    }

    /// <summary>
    /// 本函数通过助听器验配的非线性处方公式FIG.6计算患者所需要的各段压缩比以及初始值
    /// </summary>
    /// <param name="cr">生成的各段压缩比数组</param>
    /// <param name="ht">患者的听阈值</param>
    /// <param name="partNum">各通道I/O曲线段数</param>
    /// <returns>I/O曲线初始值</returns>
    public static double crCalculation(double[] cr, double ht) {
        double tklin = 45, tkhin = 75//高低拐点
                , tklout, tkhout, ig40, splout40, ig65, splout65, ig95, splout95, kk2, kk3, bb1, bb2, bb3;

        //处方公式计算
        if (ht >= 0 && ht < 20)//听阈在0-20dB HL之间
        {
            bb1 = 0;
            kk2 = 1;
            bb2 = 0;
            kk3 = 1;
            bb3 = 0;
        } else if (ht >= 20 && ht < 40)//听阈在20-40dB HL之间
        {
            ig40 = ht - 20;
            splout40 = 40 + ig40;
            bb1 = splout40 - 40;
            tklout = tklin + bb1;

            ig65 = 0.6 * (ht - 20);
            splout65 = 65 + ig65;
            kk2 = (splout65 - tklout) / (65 - tklin);
            bb2 = (tklout * 65 - splout65 * tklin) / (65 - tklin);
            tkhout = kk2 * tkhin + bb2;

            ig95 = 0;
            splout95 = 95 + ig95;
            kk3 = (splout95 - tkhout) / (95 - tkhin);
            bb3 = (tkhout * 95 - splout95 * tkhin) / (95 - tkhin);
        } else if (ht >= 40 && ht < 60)//听阈在40-60dB HL之间
        {
            ig40 = ht - 20;
            splout40 = 40 + ig40;
            bb1 = splout40 - 40;
            tklout = tklin + bb1;

            ig65 = 0.6 * (ht - 20);
            splout65 = 65 + ig65;
            kk2 = (splout65 - tklout) / (65 - tklin);
            bb2 = (tklout * 65 - splout65 * tklin) / (65 - tklin);
            tkhout = kk2 * tkhin + bb2;

            ig95 = 0.1 * Math.pow(ht - 40, 1.4);
            splout95 = 95 + ig95;
            kk3 = (splout95 - tkhout) / (95 - tkhin);
            bb3 = (tkhout * 95 - splout95 * tkhin) / (95 - tkhin);
        } else//听阈大于60dB HL
        {
            ig40 = ht - 20 - 0.5 * (ht - 60);
            splout40 = 40 + ig40;
            bb1 = splout40 - 40;
            tklout = tklin + bb1;

            ig65 = 0.8 * ht - 23;
            splout65 = 65 + ig65;
            kk2 = (splout65 - tklout) / (65 - tklin);
            bb2 = (tklout * 65 - splout65 * tklin) / (65 - tklin);
            tkhout = kk2 * tkhin + bb2;

            ig95 = 0.1 * Math.pow(ht - 40, 1.4);
            splout95 = 95 + ig95;
            kk3 = (splout95 - tkhout) / (95 - tkhin);
            bb3 = (tkhout * 95 - splout95 * tkhin) / (95 - tkhin);
        }

        //获得压缩比cr
        for (int i = 0; i < 3; i++) {
            cr[i] = 1;
        }
        for (int i = 3; i < 5; i++) {
            cr[i] = 1 / kk2;
        }
        for (int i = 5; i < partNum; i++) {
            cr[i] = 1 / kk3;
        }

        //获得初始值
        double init = bb1;
        return init;
    }

    /// <summary>
    /// 本函数用于计算I/O曲线解析式Y=kX+b
    /// </summary>
    /// <param name="k">生成的I/O曲线各段直线斜率数组</param>
    /// <param name="b">生成的I/O曲线各段直线初始值数组</param>
    /// <param name="tpi">生成的各拐点以及端点值数组</param>
    /// <param name="partNum">各通道I/O曲线段数</param>
    /// <param name="tk">各通道拐点值数组</param>
    /// <param name="cr">各通道各段压缩比数组</param>
    /// <param name="init">各通道初始值</param>
    public static void wdrcPara(double[] k, double[] b, double[] tpi, double[] tk, double[] cr, double init) {

        double[] tpo = new double[partNum + 1];

        tpi[0] = 0;
        for (int i = 1; i < partNum; i++) {
            tpi[i] = tk[i - 1];
        }
        tpi[partNum] = 120;

        tpo[0] = init;
        for (int i = 0; i < partNum; i++) {
            k[i] = 1 / cr[i];
            b[i] = tpo[i] - k[i] * tpi[i];
            tpo[i + 1] = k[i] * (tpi[i + 1]) + b[i];
        }
    }
}
